"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const env_1 = require("./lib/env");
const secp256k1_1 = require("./lib/secp256k1");
const elliptic_1 = require("./lib/elliptic");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
function generatePrivate() {
    return env_1.isNode() ? secp256k1_1.secp256k1GeneratePrivate() : elliptic_1.ellipticGeneratePrivate();
}
exports.generatePrivate = generatePrivate;
function checkPrivateKey(privateKey) {
    helpers_1.assert(privateKey.length === constants_1.KEY_LENGTH, constants_1.ERROR_BAD_PRIVATE_KEY);
    helpers_1.assert(helpers_1.isValidPrivateKey(privateKey), constants_1.ERROR_BAD_PRIVATE_KEY);
}
exports.checkPrivateKey = checkPrivateKey;
function checkPublicKey(publicKey) {
    helpers_1.assert(publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH ||
        publicKey.length === constants_1.PREFIXED_KEY_LENGTH, constants_1.ERROR_BAD_PUBLIC_KEY);
    if (publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH) {
        helpers_1.assert(publicKey[0] === 4, constants_1.ERROR_BAD_PUBLIC_KEY);
    }
    if (publicKey.length === constants_1.PREFIXED_KEY_LENGTH) {
        helpers_1.assert(publicKey[0] === 2 || publicKey[0] === 3, constants_1.ERROR_BAD_PUBLIC_KEY);
    }
}
exports.checkPublicKey = checkPublicKey;
function checkMessage(msg) {
    helpers_1.assert(msg.length > 0, constants_1.ERROR_EMPTY_MESSAGE);
    helpers_1.assert(msg.length <= constants_1.MAX_MSG_LENGTH, constants_1.ERROR_MESSAGE_TOO_LONG);
}
exports.checkMessage = checkMessage;
function compress(publicKey) {
    if (helpers_1.isCompressed(publicKey)) {
        return publicKey;
    }
    return env_1.isNode() ? secp256k1_1.secp256k1Compress(publicKey) : elliptic_1.ellipticCompress(publicKey);
}
exports.compress = compress;
function decompress(publicKey) {
    if (helpers_1.isDecompressed(publicKey)) {
        return publicKey;
    }
    return env_1.isNode()
        ? secp256k1_1.secp256k1Decompress(publicKey)
        : elliptic_1.ellipticDecompress(publicKey);
}
exports.decompress = decompress;
function getPublic(privateKey) {
    checkPrivateKey(privateKey);
    return env_1.isNode()
        ? secp256k1_1.secp256k1GetPublic(privateKey)
        : elliptic_1.ellipticGetPublic(privateKey);
}
exports.getPublic = getPublic;
function getPublicCompressed(privateKey) {
    checkPrivateKey(privateKey);
    return env_1.isNode()
        ? secp256k1_1.secp256k1GetPublicCompressed(privateKey)
        : elliptic_1.ellipticGetPublicCompressed(privateKey);
}
exports.getPublicCompressed = getPublicCompressed;
function generateKeyPair() {
    const privateKey = generatePrivate();
    const publicKey = getPublic(privateKey);
    return { privateKey, publicKey };
}
exports.generateKeyPair = generateKeyPair;
function signatureExport(sig) {
    return env_1.isNode()
        ? secp256k1_1.secp256k1SignatureExport(sig)
        : elliptic_1.ellipticSignatureExport(sig);
}
exports.signatureExport = signatureExport;
function sign(privateKey, msg, rsvSig = false) {
    checkPrivateKey(privateKey);
    checkMessage(msg);
    return env_1.isNode()
        ? secp256k1_1.secp256k1Sign(msg, privateKey, rsvSig)
        : elliptic_1.ellipticSign(msg, privateKey, rsvSig);
}
exports.sign = sign;
function recover(msg, sig, compressed = false) {
    checkMessage(msg);
    return env_1.isNode()
        ? secp256k1_1.secp256k1Recover(sig, msg, compressed)
        : elliptic_1.ellipticRecover(sig, msg, compressed);
}
exports.recover = recover;
function verify(publicKey, msg, sig) {
    checkPublicKey(publicKey);
    checkMessage(msg);
    const sigGood = env_1.isNode()
        ? secp256k1_1.secp256k1Verify(sig, msg, publicKey)
        : elliptic_1.ellipticVerify(sig, msg, publicKey);
    if (sigGood) {
        return null;
    }
    else {
        throw new Error('Bad signature');
    }
}
exports.verify = verify;
//# sourceMappingURL=ecdsa.js.map